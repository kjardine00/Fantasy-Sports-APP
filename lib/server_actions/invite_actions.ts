"use server";

import { requireAuth } from "../contexts/UserContext";
import { Invite } from "@/lib/types/database_types";
import { InviteService } from "@/lib/services/invite/invite_service";
import { LeagueService } from "@/lib/services/league/leagues_service";
import { MembersService } from "@/lib/services/league/members_service";

export async function sendLeagueInviteAction(formData: FormData) {
  const { user } = await requireAuth();
  if (!user) {
    console.error("User not logged in");
    throw new Error("User not logged in");
  }

  const email = formData.get("email") as string;
  const leagueId = formData.get("leagueId") as string;

  if (!email || !leagueId) {
    throw new Error("Email and league ID are required");
  }

  const invite: Invite = {
    // id: is generated by the database
    league_id: leagueId,
    email,
    invited_by: user.id,
    // token: is generated by the database
    status: "pending",
    // expires_at: is generated by the database
    // created_at: is generated by the database
  };

  const sentInvite = await InviteService.createAndSendInvite(invite);
  if (sentInvite.error) {
    throw new Error(sentInvite.error);
  }
  return sentInvite.data;
}

export async function fetchInviteLinkAction(leagueId: string): Promise<String> {
  const linkURL = await InviteService.createGenericInviteURL(leagueId);
  if (linkURL.error || !linkURL.data) {
    throw new Error("Generic link is unavailable");
  }
  return linkURL.data;
}

export async function validateTokenAction(token: string, userId?: string) {
  const validationResult = await InviteService.validateInviteToken(
    token,
    userId
  );

  if (validationResult.error || !validationResult.data) {
    throw new Error(
      validationResult.error || "An error occurred validating the invite token"
    );
  }

  const league = await InviteService.fetchShortCode(token);
  if (league.error || !league.data) {
    throw new Error(league.error || "An error occurred fetching the league");
  }

  return { validationResult, shortCode: league.data.short_code };
}

export async function acceptInviteAction(token: string, userId: string) {
  // 1. Validate the invite token
  const validInvite = await InviteService.validateInviteToken(token, userId);
  if (validInvite.error || !validInvite.data) {
    throw new Error(
      validInvite.error || "An error occurred validating the invite token"
    );
  }

  // 2. Find the invite
  const invite = await InviteService.findByToken(token);
  if (invite.error || !invite.data) {
    throw new Error(invite.error || "An error occurred finding the invite");
  }

  // 3. Check if the user is already a member of the league
  const member = await MembersService.getLeagueMember(
    invite.data.league_id,
    userId
  );
  if (member.data && member.data.status === "Joined") {
    throw new Error("You are already a member of this league");
  }

  // 4. Check if the league is full
  const leaguesMembers = await MembersService.getAllLeagueMembers(
    invite.data.league_id
  );
  if (leaguesMembers.error || !leaguesMembers.data) {
    throw new Error(
      leaguesMembers.error || "An error occurred finding the league members"
    );
  }
  const league = await LeagueService.getLeague(invite.data.league_id);
  if (league.error || !league.data) {
    throw new Error(league.error || "An error occurred finding the league");
  }
  if (leaguesMembers.data.length >= league.data.settings.numberOfTeams!) {
    throw new Error("This league is full");
  }

  // 5. Create the new member
  const newMemberResult = await MembersService.createMember({
    league_id: invite.data.league_id,
    user_id: userId,
    role: "member",
    league_number: 1,
    abbreviation: null,
    team_name: null,
    status: "Joined",
  });

  if (newMemberResult.error || !newMemberResult.data) {
    throw new Error(
      newMemberResult.error || "An error occurred creating the member"
    );
  }

  // 6. Increment the invite usage
  const inviteUseCount = await InviteService.incrementUsage(invite.data.id!);
  if (inviteUseCount.error || !inviteUseCount.data) {
    throw new Error(
      inviteUseCount.error || "An error occurred incrementing the invite usage"
    );
  }
  // 7. Deactivate the invite if it has reached the maximum number of uses
  if (
    inviteUseCount.data.max_uses &&
    (inviteUseCount.data.current_uses ?? 0) >= inviteUseCount.data.max_uses
  ) {
    const deactivateResult = await InviteService.deactivateByLeagueId(
      invite.data.league_id
    );
    if (deactivateResult.error || !deactivateResult.data) {
      throw new Error(
        deactivateResult.error || "An error occurred deactivating the invite"
      );
    }
  }
  return { success: true, shortCode: league.data.short_code };
}
